# 首先，这道题目要求在原数组中进行修改，而不增加另外的存储空间使用
# 那么基于这个要求，我们采取的策略就是同时遍历两个数组，
# 如果在数组一中有元素大于等于数组二中的元素，那么我们就将数组二中的元素插入到数组一中该元素之前的位置
# 在进行元素插入的时候，我们会把数组一中从该元素开始的位置的元素，全部向后移动一个位置
# 由于，题目假设数组一的长度是可以容纳两个数组的元素的，所以我们不用担心下标访问越界的问题，
# 同时，在向数组一中插入元素之后，我们需要把数组一的长度加1
# 在遍历完，数组一中的所有元素遍历完成之后，我们还需要检查数组二中是否还有剩余的元素，
# 如果有，直接把剩余的元素插入到数组一中的末尾即可。
# 因为，在之前遍历数组一的时候插入的元素，都是比数组一中的元素小的元素
# 那么，剩余的元素都是比数组一中所有元素大的元素，因而直接放在数组一的末尾即可。
class Solution:
	def merge(self, nums1, m, nums2, n):
		i = j = 0
		while i < m and j < n:
			if nums1[i] >= nums2[j]:
				nums1[i+1:] = nums2[i:-1]
				nums1[i] = nums2[j]
				i += 1
				j += 1
				m += 1
			else:
				i += 1
		while j < n and i < len(nums1):
			nums1[i] = nums2[j]
			i += 1
			j += 1

